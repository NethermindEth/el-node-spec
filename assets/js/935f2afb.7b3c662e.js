"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"sidebar":[{"type":"link","label":"Introduction","href":"/docs/introduction","docId":"introduction"},{"type":"category","label":"AVS Node Specification","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/spec/intro","docId":"spec/intro"},{"type":"category","label":"AVS Node API","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"AVS Node API","href":"/docs/spec/api/","docId":"spec/api/api"},{"type":"link","label":"Implementation reference","href":"/docs/spec/api/api-examples","docId":"spec/api/api-examples"}],"href":"/docs/category/avs-node-api"},{"type":"category","label":"Metrics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Prometheus Metrics Specification","href":"/docs/spec/metrics/metrics-prom-spec","docId":"spec/metrics/metrics-prom-spec"},{"type":"link","label":"Implementation reference","href":"/docs/spec/metrics/metrics-examples","docId":"spec/metrics/metrics-examples"}],"href":"/docs/category/metrics"},{"type":"category","label":"Plugin","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/spec/plugin/intro","docId":"spec/plugin/intro"}],"href":"/docs/category/plugin"}],"href":"/docs/category/avs-node-specification"},{"type":"category","label":"Key Management","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/keys/intro","docId":"keys/intro"},{"type":"link","label":"Key Security Considerations for Developers","href":"/docs/keys/middleware-developers","docId":"keys/middleware-developers"},{"type":"link","label":"Key Management Best Practices for Solo Stakers","href":"/docs/keys/solo-stakers","docId":"keys/solo-stakers"},{"type":"link","label":"Key Management Best Practices for Node Operators","href":"/docs/keys/node-operators","docId":"keys/node-operators"}],"href":"/docs/category/key-management"},{"type":"link","label":"Glossary","href":"/docs/glossary","docId":"glossary"}]},"docs":{"glossary":{"id":"glossary","title":"Glossary","description":"- Glossary","sidebar":"sidebar"},"introduction":{"id":"introduction","title":"Introduction","description":"In the EigenLayer ecosystem, Ethereum validators can restake their beacon chain ETH, accept delegations in the form of native ETH or LSTs, and run node software specific to Actively Validated Services (AVS). A Data Availability Layer such as EigenDA serves as a prime example of an AVS.","sidebar":"sidebar"},"keys/intro":{"id":"keys/intro","title":"Introduction","description":"This section presents key management suggestions for both developers and users. Within the context of EigenLayer, developers ought to be acquainted with proper practices concerning key loading, particularly signing keys, while stakers (users) should understand how to manage them effectively.","sidebar":"sidebar"},"keys/middleware-developers":{"id":"keys/middleware-developers","title":"Key Security Considerations for Developers","description":"When working with keys in Nodes or AVS, it is essential to consider the security aspects associated with key access and decryption. Keys should be encrypted either using a password or passphrase, understanding the unique security concerns posed by different access layers is crucial. By proactively addressing these concerns, you can enhance the overall security and integrity of the keys within your system:","sidebar":"sidebar"},"keys/node-operators":{"id":"keys/node-operators","title":"Key Management Best Practices for Node Operators","description":"For Node Operators, such as institutional stakers or those managing numerous validator keys, staking services like Twinstake can be advantageous, as they allow for continuous fund control while combining technical, risk, and treasury management expertise. With such services, there is no need to maintain infrastructure or develop safe key signing or management mechanisms. However, some Node Operators possess the resources to deploy and maintain the required infrastructure for running nodes effectively for multiple validator keys. A detailed blog discussing various security layers can be found here.","sidebar":"sidebar"},"keys/solo-stakers":{"id":"keys/solo-stakers","title":"Key Management Best Practices for Solo Stakers","description":"Individuals managing a limited number of validator keys typically do not require intricate distributed infrastructure for running nodes or employing remote signers. For these individuals, extensive staking services may be excessive and unnecessary. This means they will often store the keys with the decryption keys locally with the validator client or Node (which they maintain), which increases the vulnerability of the secrets, but, while stakers must safeguard validator keys against attacks, most key losses typically result from mundane reasons, such as losing the hardware containing the key. Users necessitate a backup strategy, mindful that if an attacker accesses the backed-up keys, they can sign any message deemed valid against the validator\'s public key. Appropriate precautions should be implemented to guarantee that backed-up validator keys are as inaccessible as feasible, ideally being completely offline and physically secure. Some of these precautions can be listed:","sidebar":"sidebar"},"spec/api/api":{"id":"spec/api/api","title":"AVS Node API","description":"The AVS Node HTTP RESTful API provides a common interface for Nodes designed for the EigenLayer protocol.","sidebar":"sidebar"},"spec/api/api-examples":{"id":"spec/api/api-examples","title":"Implementation reference","description":"This guide is intended to showcase the practical application of the AVS Node API using authentic examples. Examples used are:","sidebar":"sidebar"},"spec/intro":{"id":"spec/intro","title":"Introduction","description":"This is a specification for running EigenLayer AVS Nodes. AVS is used to participate in the EigenLayer restaking system, to know more about EigenLayer see its documentation page.","sidebar":"sidebar"},"spec/metrics/metrics-examples":{"id":"spec/metrics/metrics-examples","title":"Implementation reference","description":"This guide is intended to showcase the practical application of the Prometheus metrics using authentic examples. Examples used are:","sidebar":"sidebar"},"spec/metrics/metrics-prom-spec":{"id":"spec/metrics/metrics-prom-spec","title":"Prometheus Metrics Specification","description":"The table below defines metrics which may be captured by AVS Nodes which expose metrics to Prometheus. AVSs may expose additional metrics however these should not use the eigen_ prefix.","sidebar":"sidebar"},"spec/plugin/intro":{"id":"spec/plugin/intro","title":"Introduction","description":"The plugin system provides a way to add new functionalities that are not included by default. This is necessary due to the diversity of services and structure that an AVS Node could have. Each AVS Node could provide a plugin to extend the setup tool with AVS-specific functionalities interacting with the services declared in the docker-compose setup.","sidebar":"sidebar"}}}')}}]);