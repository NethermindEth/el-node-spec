"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[185],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>h});var n=r(7294);function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,n,s=function(e,t){if(null==e)return{};var r,n,s={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(s[r]=e[r]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var r=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,d=a(e,["components","mdxType","originalType","parentName"]),p=l(r),y=s,h=p["".concat(c,".").concat(y)]||p[y]||u[y]||o;return r?n.createElement(h,i(i({ref:t},d),{},{components:r})):n.createElement(h,i({ref:t},d))}));function h(e,t){var r=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=r.length,i=new Array(o);i[0]=y;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a[p]="string"==typeof e?e:s,i[1]=a;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}y.displayName="MDXCreateElement"},4527:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var n=r(7462),s=(r(7294),r(3905));const o={sidebar_position:2,id:"middleware-developers"},i="Key Security Considerations for Developers",a={unversionedId:"keys/middleware-developers",id:"keys/middleware-developers",title:"Key Security Considerations for Developers",description:"When working with keys in Nodes or AVS, it is essential to consider the security aspects associated with key access and decryption. Keys should be encrypted either using a password or passphrase, understanding the unique security concerns posed by different access layers is crucial. By proactively addressing these concerns, you can enhance the overall security and integrity of the keys within your system:",source:"@site/docs/keys/developers.md",sourceDirName:"keys",slug:"/keys/middleware-developers",permalink:"/docs/keys/middleware-developers",draft:!1,editUrl:"https://github.com/NethermindEth/el-node-spec/edit/main/docs/docs/keys/developers.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,id:"middleware-developers"},sidebar:"sidebar",previous:{title:"Introduction",permalink:"/docs/keys/intro"},next:{title:"Key Management Best Practices for Solo Stakers",permalink:"/docs/keys/solo-stakers"}},c={},l=[{value:"Key Management Recommendation for Developers",id:"key-management-recommendation-for-developers",level:2}],d={toc:l},p="wrapper";function u(e){let{components:t,...r}=e;return(0,s.kt)(p,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"key-security-considerations-for-developers"},"Key Security Considerations for Developers"),(0,s.kt)("p",null,"When working with keys in Nodes or AVS, it is essential to consider the security aspects associated with key access and decryption. Keys should be encrypted either using a password or passphrase, understanding the unique security concerns posed by different access layers is crucial. By proactively addressing these concerns, you can enhance the overall security and integrity of the keys within your system:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Prompt for the passphrase and store it in memory:"),"  In this scenario, the input must remain hidden to prevent the secret phrase from being stored in the terminal session or used buffer. Attackers might search for this secret in the buffer history. The key should not be stored locally or remotely unless encrypted via the AVS's proprietary methods.\n"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Request the path to a file containing the passphrase:"),"  Here, buffer vulnerability issues are absent unless the secret is printed or logged. However, an attacker with access to the machine running the AVS could potentially access this file.\n"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Retrieve the key remotely:"),"  Encrypting the validator key offers markedly improved protection when the decryption passphrase is stored remotely. Since the passphrase is not located within the validator client's storage, obtaining an unencrypted key from on-disk data becomes impossible. Instead, an attacker would need to execute considerably more advanced attacks, such as extracting the decrypted key from memory or impersonating the validator client process to receive the decryption key.","  Nonetheless, despite the increased difficulty, a sophisticated attack could still potentially acquire the validator key. Moreover, the user may inadvertently sign undesirable messages.\n"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Utilize remote signers:"),"  Employing remote signers involves delegating the signing process to an external service or device, which can offer additional security layers. The users are responsible for the availability and security of the remote signers, however, it is crucial to establish secure communication channels and verify the trustworthiness of the remote signer to prevent unauthorized access or tampering.")),(0,s.kt)("p",null,"Supporting both local and remote signer methods is a good practice. "),(0,s.kt)("p",null,"A good choice for a remote signer is ",(0,s.kt)("a",{parentName:"p",href:"https://docs.web3signer.consensys.net/"},"Web3signer"),":"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Open-source signing service developed under the Apache 2.0 license, developed by Consensys, and written in Java. "),(0,s.kt)("li",{parentName:"ul"},"Capable of signing on multiple platforms using private keys stored in an external vault, or encrypted on a disk."),(0,s.kt)("li",{parentName:"ul"},"Can sign payloads using secp256k1 and BLS12-381 signing keys (AWS HSM can't at the moment, spring 2023)."),(0,s.kt)("li",{parentName:"ul"},"Web3Signer uses REST APIs, and all the major Ethereum Consensus clients support it.")),(0,s.kt)("h2",{id:"key-management-recommendation-for-developers"},"Key Management Recommendation for Developers"),(0,s.kt)("p",null,"The AVS can implement a feasible and sufficient method of loading the keys. This is asking for a path to a keystore folder. This keystore needs to follow some structure that AVS knows how to read. Currently ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/NethermindEth/eigenlayer#create-and-list-keys"},"eigenlayer-cli")," supports creation of encrypted ecdsa and bn254 keys in the ",(0,s.kt)("a",{parentName:"p",href:"https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/"},"web3 secret storage")," format. "),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"By keys, we refer to any kind of secret, either in plain text or encrypted.")),(0,s.kt)("p",null,"The path to this keystore folder can be provided via an environment variable or argument."))}u.isMDXComponent=!0}}]);