"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"sidebar":[{"type":"link","label":"Introduction","href":"/docs/introduction","docId":"introduction"},{"type":"category","label":"AVS Node Specification","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/spec/intro","docId":"spec/intro"},{"type":"category","label":"Packaging & Upgrading","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Packaging procedure","href":"/docs/spec/packaging/","docId":"spec/packaging/packaging"},{"type":"link","label":"Manifest file","href":"/docs/spec/packaging/manifest","docId":"spec/packaging/manifest"},{"type":"link","label":"Profile file","href":"/docs/spec/packaging/profiles","docId":"spec/packaging/profiles"},{"type":"link","label":"Reference package","href":"/docs/spec/packaging/reference","docId":"spec/packaging/reference"},{"type":"link","label":"Packaging Best Practices","href":"/docs/spec/packaging/guidelines","docId":"spec/packaging/guidelines"},{"type":"link","label":"Keeping AVS Software Easily Updatable","href":"/docs/spec/packaging/upgrading","docId":"spec/packaging/upgrading"}],"href":"/docs/category/packaging--upgrading"},{"type":"category","label":"AVS Node API","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"AVS Node API","href":"/docs/spec/api/","docId":"spec/api/api"},{"type":"link","label":"Implementation reference","href":"/docs/spec/api/api-examples","docId":"spec/api/api-examples"}],"href":"/docs/category/avs-node-api"},{"type":"category","label":"Metrics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Prometheus Metrics Specification","href":"/docs/spec/metrics/metrics-prom-spec","docId":"spec/metrics/metrics-prom-spec"},{"type":"link","label":"Implementation reference","href":"/docs/spec/metrics/metrics-examples","docId":"spec/metrics/metrics-examples"}],"href":"/docs/category/metrics"},{"type":"category","label":"Plugin","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/spec/plugin/intro","docId":"spec/plugin/intro"}],"href":"/docs/category/plugin"}],"href":"/docs/category/avs-node-specification"},{"type":"category","label":"AVS Setup Wizard","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/wizard/intro","docId":"wizard/intro"},{"type":"category","label":"Monitoring Stack","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/wizard/monitoring/intro","docId":"wizard/monitoring/intro"},{"type":"link","label":"Prometheus","href":"/docs/wizard/monitoring/prometheus","docId":"wizard/monitoring/prometheus"},{"type":"link","label":"Node Exporter","href":"/docs/wizard/monitoring/node-exporter","docId":"wizard/monitoring/node-exporter"},{"type":"link","label":"Grafana","href":"/docs/wizard/monitoring/grafana","docId":"wizard/monitoring/grafana"}],"href":"/docs/category/monitoring-stack"},{"type":"category","label":"Backup and Restore","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/wizard/backup/intro","docId":"wizard/backup/intro"},{"type":"link","label":"Backup service","href":"/docs/wizard/backup/","docId":"wizard/backup/backup"},{"type":"link","label":"Restore service","href":"/docs/wizard/backup/restore","docId":"wizard/backup/restore"}],"href":"/docs/category/backup-and-restore"}],"href":"/docs/category/avs-setup-wizard"},{"type":"category","label":"Keys Management","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/keys/intro","docId":"keys/intro"},{"type":"link","label":"Key Security Considerations for Developers","href":"/docs/keys/middleware-developers","docId":"keys/middleware-developers"},{"type":"link","label":"Key Management Best Practices for Solo Stakers","href":"/docs/keys/solo-stakers","docId":"keys/solo-stakers"},{"type":"link","label":"Key Management Best Practices for Node Operators","href":"/docs/keys/node-operators","docId":"keys/node-operators"}],"href":"/docs/category/keys-management"},{"type":"link","label":"Glossary","href":"/docs/glossary","docId":"glossary"}]},"docs":{"glossary":{"id":"glossary","title":"Glossary","description":"- Glossary","sidebar":"sidebar"},"introduction":{"id":"introduction","title":"Introduction","description":"The EigenLayer ecosystem allows Ethereum validators to restake their ETH and provide services to the network, such as a Data Availability Layer with a particular type of node software called Actively Validated Services (AVS).","sidebar":"sidebar"},"keys/intro":{"id":"keys/intro","title":"Introduction","description":"This section presents key management suggestions for both developers and users. Within the context of EigenLayer, developers ought to be acquainted with proper practices concerning key loading, particularly signing keys, while stakers (users) should understand how to manage them effectively.","sidebar":"sidebar"},"keys/middleware-developers":{"id":"keys/middleware-developers","title":"Key Security Considerations for Developers","description":"When working with keys in Nodes or AVS, it is essential to consider the security aspects associated with key access and decryption. Keys should be encrypted either using a password or passphrase, understanding the unique security concerns posed by different access layers is crucial. By proactively addressing these concerns, you can enhance the overall security and integrity of the keys within your system:","sidebar":"sidebar"},"keys/node-operators":{"id":"keys/node-operators","title":"Key Management Best Practices for Node Operators","description":"For Node Operators, such as institutional stakers or those managing numerous validator keys, staking services like Twinstake can be advantageous, as they allow for continuous fund control while combining technical, risk, and treasury management expertise. With such services, there is no need to maintain infrastructure or develop safe key signing or management mechanisms. However, some Node Operators possess the resources to deploy and maintain the required infrastructure for running nodes effectively for multiple validator keys. A detailed blog discussing various security layers can be found here.","sidebar":"sidebar"},"keys/solo-stakers":{"id":"keys/solo-stakers","title":"Key Management Best Practices for Solo Stakers","description":"Individuals managing a limited number of validator keys typically do not require intricate distributed infrastructure for running nodes or employing remote signers. For these individuals, extensive staking services may be excessive and unnecessary. This means they will often store the keys with the decryption keys locally with the validator client or Node (which they maintain), which increases the vulnerability of the secrets, but, while stakers must safeguard validator keys against attacks, most key losses typically result from mundane reasons, such as losing the hardware containing the key. Users necessitate a backup strategy, mindful that if an attacker accesses the backed-up keys, they can sign any message deemed valid against the validator\'s public key. Appropriate precautions should be implemented to guarantee that backed-up validator keys are as inaccessible as feasible, ideally being completely offline and physically secure. Some of these precautions can be listed:","sidebar":"sidebar"},"spec/api/api":{"id":"spec/api/api","title":"AVS Node API","description":"The AVS Node HTTP RESTful API provides a common interface for Nodes designed for the EigenLayer protocol.","sidebar":"sidebar"},"spec/api/api-examples":{"id":"spec/api/api-examples","title":"Implementation reference","description":"This guide is intended to showcase the practical application of the AVS Node API using authentic examples. Examples used are:","sidebar":"sidebar"},"spec/intro":{"id":"spec/intro","title":"Introduction","description":"This is a specification for the packaging, installation, update, and monitoring process of EigenLayer Nodes. AVS is used to participate in the EigenLayer restaking system, to know more about EigenLayer see its documentation page.","sidebar":"sidebar"},"spec/metrics/metrics-examples":{"id":"spec/metrics/metrics-examples","title":"Implementation reference","description":"This guide is intended to showcase the practical application of the Prometheus metrics using authentic examples. Examples used are:","sidebar":"sidebar"},"spec/metrics/metrics-prom-spec":{"id":"spec/metrics/metrics-prom-spec","title":"Prometheus Metrics Specification","description":"The table below defines metrics which may be captured by AVS Nodes which expose metrics to Prometheus. AVSs may expose additional metrics however these should not use the eigen_ prefix.","sidebar":"sidebar"},"spec/packaging/guidelines":{"id":"spec/packaging/guidelines","title":"Packaging Best Practices","description":"- Packaging Best Practices","sidebar":"sidebar"},"spec/packaging/manifest":{"id":"spec/packaging/manifest","title":"Manifest file","description":"The Manifest file is an essential component of the AVS Node package structure. It provides crucial information about the AVS version, its name, and the list of profiles that are included in the package. The upgrade field of the Manifest file indicates whether an upgrade is optional, recommended, or required, which allows users to determine how and when to upgrade their AVS to the latest version.","sidebar":"sidebar"},"spec/packaging/packaging":{"id":"spec/packaging/packaging","title":"Packaging procedure","description":"AVS Nodes in the EigenLayer Protocol under the proposed specification comprise of Docker containers running alongside backing services such as databases, indexers, and utility services. Developers are responsible for defining these services and their options well to work correctly. The objective is to create a standard interface to manage the setup, configuration, and updates of these AVS Nodes.","sidebar":"sidebar"},"spec/packaging/profiles":{"id":"spec/packaging/profiles","title":"Profile file","description":"The configuration/profile file should be in YAML format and contain information about the AVS Node profile and its options. Options are any argument, flag, configuration value, or environment variable of any services within the AVS Node docker-compose.yml whose value might be required from the user input.","sidebar":"sidebar"},"spec/packaging/reference":{"id":"spec/packaging/reference","title":"Reference package","description":"Package structure","sidebar":"sidebar"},"spec/packaging/upgrading":{"id":"spec/packaging/upgrading","title":"Keeping AVS Software Easily Updatable","description":"Ensuring that your AVS software is easily updatable by users is crucial for a smooth user experience. Users should be able to update your software without making changes to CLI commands, Docker files, or dealing with schema and database version updates manually. Here\'s a guide on how to achieve this.","sidebar":"sidebar"},"spec/plugin/intro":{"id":"spec/plugin/intro","title":"Introduction","description":"The plugin system will provide a way to extend the AVS setup wizard tool with new functionalities that are not included by default. This is necessary due to the diversity of services and structure that an AVS Node could have. Each AVS Node could provide a plugin to extend the setup tool with AVS-specific functionalities interacting with the services declared in the docker-compose setup.","sidebar":"sidebar"},"wizard/backup/backup":{"id":"wizard/backup/backup","title":"Backup service","description":"Commit container","sidebar":"sidebar"},"wizard/backup/intro":{"id":"wizard/backup/intro","title":"Introduction","description":"Backup and restore functionalities are necessary to support rollback and disaster recovery. This section introduces the rollback strategy and how the backup and restore actions will be made.","sidebar":"sidebar"},"wizard/backup/restore":{"id":"wizard/backup/restore","title":"Restore service","description":"Restore container","sidebar":"sidebar"},"wizard/intro":{"id":"wizard/intro","title":"Introduction","description":"The specification described throughout this document can be used to manage multiple AVS Nodes in the same host machine with a AVS wizard setup tool. Such a tool will be built and will provide the following functionalities:","sidebar":"sidebar"},"wizard/monitoring/grafana":{"id":"wizard/monitoring/grafana","title":"Grafana","description":"Grafana Dashboards is an open source solution for metrics visualization. In this case, Grafana is used to visualize metrics collected by the Prometheus instance from all the AVSs and the host machine.","sidebar":"sidebar"},"wizard/monitoring/intro":{"id":"wizard/monitoring/intro","title":"Introduction","description":"Deploying the Monitoring Stack is the responsibility of the AVS setup wizard tool and is the set of following services:","sidebar":"sidebar"},"wizard/monitoring/node-exporter":{"id":"wizard/monitoring/node-exporter","title":"Node Exporter","description":"The AVS setup wizard tool would deploy the Node Exporter instance as part of the Monitoring Stack to collect metrics from the host machine. To know more about how to visualize the Node Exporter metrics in Grafana, read the Host Metrics dashboard documentation.","sidebar":"sidebar"},"wizard/monitoring/prometheus":{"id":"wizard/monitoring/prometheus","title":"Prometheus","description":"The AVS setup wizard tool would deploy the Prometheus instance as part of the Monitoring Stack to collect metrics from the host machine and AVS Nodes. Initially, the only target would be the Node Exporter, but AVS Node targets could be added dynamically by the tool when a new AVS Node is deployed.","sidebar":"sidebar"}}}')}}]);