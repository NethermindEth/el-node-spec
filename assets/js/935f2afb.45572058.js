"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Intro","href":"/docs/intro","docId":"intro"},{"type":"category","label":"Packaging & Upgrading","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Packaging procedure","href":"/docs/packaging/","docId":"packaging/packaging"},{"type":"link","label":"Manifest file","href":"/docs/packaging/manifest","docId":"packaging/manifest"},{"type":"link","label":"Profile file","href":"/docs/packaging/profiles","docId":"packaging/profiles"},{"type":"link","label":"Reference package","href":"/docs/packaging/reference","docId":"packaging/reference"},{"type":"link","label":"Keeping Middleware Software Easily Updatable","href":"/docs/packaging/upgrading","docId":"packaging/upgrading"}]},{"type":"category","label":"Backup and Restore","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/backup/intro","docId":"backup/intro"},{"type":"link","label":"Backup service","href":"/docs/backup/","docId":"backup/backup"},{"type":"link","label":"Restore service","href":"/docs/backup/restore","docId":"backup/restore"}],"href":"/docs/category/backup-and-restore"},{"type":"category","label":"Plugin","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/plugin/intro","docId":"plugin/intro"}],"href":"/docs/category/plugin"},{"type":"category","label":"Keys Management","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/keys/intro","docId":"keys/intro"},{"type":"link","label":"Key Security Considerations for Middleware Developers","href":"/docs/keys/middleware-developers","docId":"keys/middleware-developers"},{"type":"link","label":"Key Management Best Practices for Solo Stakers","href":"/docs/keys/solo-stakers","docId":"keys/solo-stakers"},{"type":"link","label":"Key Management Best Practices for Node Operators","href":"/docs/keys/node-operators","docId":"keys/node-operators"}],"href":"/docs/category/keys-management"},{"type":"category","label":"Metrics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"EigenLayer Middleware API","href":"/docs/metrics/metrics-api","docId":"metrics/metrics-api"},{"type":"link","label":"Prometheus Metrics Specification","href":"/docs/metrics/metrics-prom-spec","docId":"metrics/metrics-prom-spec"},{"type":"link","label":"Implementation reference","href":"/docs/metrics/metrics-examples","docId":"metrics/metrics-examples"}],"href":"/docs/category/metrics"},{"type":"category","label":"Monitoring Stack","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/monitoring/intro","docId":"monitoring/intro"},{"type":"link","label":"Prometheus","href":"/docs/monitoring/prometheus","docId":"monitoring/prometheus"},{"type":"link","label":"Node Exporter","href":"/docs/monitoring/node-exporter","docId":"monitoring/node-exporter"},{"type":"link","label":"Grafana","href":"/docs/monitoring/grafana","docId":"monitoring/grafana"}],"href":"/docs/category/monitoring-stack"},{"type":"category","label":"Graft","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/docs/graft/intro","docId":"graft/intro"},{"type":"link","label":"Configuration","href":"/docs/graft/config","docId":"graft/config"},{"type":"link","label":"Dashboards","href":"/docs/graft/dashboards","docId":"graft/dashboards"},{"type":"link","label":"Panels","href":"/docs/graft/panels","docId":"graft/panels"},{"type":"link","label":"Demo","href":"/docs/graft/demo","docId":"graft/demo"},{"type":"link","label":"The UID importance","href":"/docs/graft/the-uid-importance","docId":"graft/the-uid-importance"}],"href":"/docs/category/graft"}]},"docs":{"backup/backup":{"id":"backup/backup","title":"Backup service","description":"Commit container","sidebar":"tutorialSidebar"},"backup/intro":{"id":"backup/intro","title":"Introduction","description":"Backup and restore functionalities are necessary to support rollback and disaster recovery. This section introduces the rollback strategy and how the backup and restore actions will be made.","sidebar":"tutorialSidebar"},"backup/restore":{"id":"backup/restore","title":"Restore service","description":"Restore container","sidebar":"tutorialSidebar"},"graft/config":{"id":"graft/config","title":"Configuration","description":"Configuration file could be used to list all the data sources required to build dashboards and panels. This file is the graft.yml file in the current directory by default but could be specified using the global flag --config/-c. E.g.:","sidebar":"tutorialSidebar"},"graft/dashboards":{"id":"graft/dashboards","title":"Dashboards","description":"Init dashboard","sidebar":"tutorialSidebar"},"graft/demo":{"id":"graft/demo","title":"Demo","description":"This section contains the step sequence to create dashboards and panels using graft.","sidebar":"tutorialSidebar"},"graft/intro":{"id":"graft/intro","title":"Introduction","description":"Graft aims to help developers to create Grafana dashboards using Library Panels. Library Panels helps maintain the modularity of dashboards, and end users can build their own dashboards using these panels. With graft you could do these main actions:","sidebar":"tutorialSidebar"},"graft/panels":{"id":"graft/panels","title":"Panels","description":"Init panel","sidebar":"tutorialSidebar"},"graft/the-uid-importance":{"id":"graft/the-uid-importance","title":"The UID importance","description":"The uid property is a unique string identifier inside the Grafana database. The good usage of this property is important because all the relations between objects (folder \u2194\xa0panel \u2194\xa0dashboard \u2194\xa0datasource) uses this property. The user has the power to define these properties while initializing any of the objects. Take in mind that the uid is a value that will present in the backup files that the end user will import on its Grafana instance, so a good name pattern is useful to avoid collisions between multiple middleware collections, we propose to use this name pattern:","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Intro","description":"","sidebar":"tutorialSidebar"},"keys/intro":{"id":"keys/intro","title":"Introduction","description":"This section presents key management suggestions for both developers and users. Within the context of EigenLayer, Middleware providers (developers) ought to be acquainted with proper practices concerning key loading, particularly signing keys, while stakers (users) should understand how to manage them effectively.","sidebar":"tutorialSidebar"},"keys/middleware-developers":{"id":"keys/middleware-developers","title":"Key Security Considerations for Middleware Developers","description":"When working with keys in Middleware services or related tools, it is essential to consider the security aspects associated with key access and decryption. Keys should be encrypted either using a password or passphrase, understanding the unique security concerns posed by different access layers is crucial. By proactively addressing these concerns, you can enhance the overall security and integrity of the keys within your system:","sidebar":"tutorialSidebar"},"keys/node-operators":{"id":"keys/node-operators","title":"Key Management Best Practices for Node Operators","description":"For Node Operators, such as institutional stakers or those managing numerous validator keys, staking services like Twinstake can be advantageous, as they allow for continuous fund control while combining technical, risk, and treasury management expertise. With such services, there is no need to maintain infrastructure or develop safe key signing or management mechanisms. However, some Node Operators possess the resources to deploy and maintain the required infrastructure for running nodes and Middleware services effectively for multiple validator keys. A detailed blog discussing various security layers can be found here.","sidebar":"tutorialSidebar"},"keys/solo-stakers":{"id":"keys/solo-stakers","title":"Key Management Best Practices for Solo Stakers","description":"Individuals managing a limited number of validator keys typically do not require intricate distributed infrastructure for running nodes or employing remote signers. For these individuals, extensive staking services may be excessive and unnecessary. This means they will often store the keys with the decryption keys locally with the validator client or Middleware service (which they maintain), which increases the vulnerability of the secrets, but, while stakers must safeguard validator keys against attacks, most key losses typically result from mundane reasons, such as losing the hardware containing the key. Users necessitate a backup strategy, mindful that if an attacker accesses the backed-up keys, they can sign any message deemed valid against the validator\'s public key. Appropriate precautions should be implemented to guarantee that backed-up validator keys are as inaccessible as feasible, ideally being completely offline and physically secure. Some of these precautions can be listed:","sidebar":"tutorialSidebar"},"metrics/metrics-api":{"id":"metrics/metrics-api","title":"EigenLayer Middleware API","description":"The EigenLayer Middleware API provides monitoring and common metrics for middleware services designed for the EigenLayer protocol.","sidebar":"tutorialSidebar"},"metrics/metrics-examples":{"id":"metrics/metrics-examples","title":"Implementation reference","description":"This guide is intended to showcase the practical application of monitoring APIs and Prometheus metrics using authentic examples. Examples used are:","sidebar":"tutorialSidebar"},"metrics/metrics-prom-spec":{"id":"metrics/metrics-prom-spec","title":"Prometheus Metrics Specification","description":"The table below defines metrics which may be captured by Middleware services which expose metrics to Prometheus. Middleware services may expose additional metrics however these should not use the eigen prefix. The label middlewarename allows identification of Middleware services and we strongly recommend to use that label in any additional or custom metric the Middleware provides.","sidebar":"tutorialSidebar"},"monitoring/grafana":{"id":"monitoring/grafana","title":"Grafana","description":"Grafana Dashboards is an open source solution for metrics visualization. In this case, Grafana is used to visualize metrics collected by the Prometheus instance from all the middlewares and the host machine.","sidebar":"tutorialSidebar"},"monitoring/intro":{"id":"monitoring/intro","title":"Introduction","description":"Deploying the Monitoring Stack is the responsibility of a Middleware setup wizard tool and is the set of following services:","sidebar":"tutorialSidebar"},"monitoring/node-exporter":{"id":"monitoring/node-exporter","title":"Node Exporter","description":"A Middleware setup wizard tool would deploy the Node Exporter instance as part of the Monitoring Stack to collect metrics from the host machine. To know more about how to visualize the Node Exporter metrics in Grafana, read the Host Metrics dashboard documentation.","sidebar":"tutorialSidebar"},"monitoring/prometheus":{"id":"monitoring/prometheus","title":"Prometheus","description":"A Middleware setup wizard tool would deploy the Prometheus instance as part of the Monitoring Stack to collect metrics from the host machine and middleware services. Initially, the only target would be the Node Exporter, but middleware targets could be added dynamically by the tool when a new middleware is deployed.","sidebar":"tutorialSidebar"},"packaging/manifest":{"id":"packaging/manifest","title":"Manifest file","description":"The Manifest file is an essential component of the Middleware package structure. It provides crucial information about the Middleware version, its name, and the list of profiles that are included in the package. The upgrade field of the Manifest file indicates whether an upgrade is optional, recommended, or required, which allows users to determine how and when to upgrade their Middleware to the latest version.","sidebar":"tutorialSidebar"},"packaging/packaging":{"id":"packaging/packaging","title":"Packaging procedure","description":"Middleware Services in the EigenLayer Protocol under the proposed specification comprise of Docker containers running alongside backing services such as databases, indexers, and utility services. Middleware developers are responsible for defining these services and their options well to work correctly. The objective is to create a standard interface to manage the setup, configuration, and updates of these Middleware Services.","sidebar":"tutorialSidebar"},"packaging/profiles":{"id":"packaging/profiles","title":"Profile file","description":"The configuration/profile file should be in YAML format and contain information about the Middleware profile and its options. Options are any argument, flag, configuration value, or environment variable of any services within the Middleware service docker-compose.yml whose value might be required from the user input.","sidebar":"tutorialSidebar"},"packaging/reference":{"id":"packaging/reference","title":"Reference package","description":"Package structure","sidebar":"tutorialSidebar"},"packaging/upgrading":{"id":"packaging/upgrading","title":"Keeping Middleware Software Easily Updatable","description":"Ensuring that your middleware software is easily updatable by users is crucial for a smooth user experience. Users should be able to update your software without making changes to CLI commands, Docker files, or dealing with schema and database version updates manually. Here\'s a guide on how to achieve this.","sidebar":"tutorialSidebar"},"plugin/intro":{"id":"plugin/intro","title":"Introduction","description":"The plugin system will provide a way to extend the Middleware setup tool with new functionalities that are not included by default. This is necessary due to the diversity of services and structure that a middleware could have. Each middleware could provide a plugin to extend the setup tool with middleware-specific functionalities interacting with the services declared in the docker-compose setup.","sidebar":"tutorialSidebar"}}}')}}]);